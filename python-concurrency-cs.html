<!DOCTYPE html>

<html>
   <head>
   
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
      <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
      <link rel="stylesheet" href="highlight/styles/github.css">
      <link rel="stylesheet" href="css/style.css">
      <script src="highlight/highlight.pack.js"></script>
      <script>
         $(document).ready(function(){
            $('pre.code').each(function(i, block) {
               hljs.highlightBlock(block);
            }); 
         });
      </script> 
   </head>

   <body>
      <div class="container">
         <div class="jumbotron" style="background-color:white">
            <h1>Python Cheat Sheet</h1>
            <p>Cheat sheet of Python. Some concurrency concept for Python programmer need to know.</p>
         </div>
         <div class="row">
            <div class="col-sm-4">
<h3>Create a Thread Via threading</h3>
<pre class="code python">
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; class Worker(Thread):
...   def __init__(self, id):
...     super(Worker, self).__init__()
...     self._id = id
...   def run(self):
...     print "I am worker %d" % self._id
... 
&gt;&gt;&gt; t1 = Worker(1)
&gt;&gt;&gt; t2 = Worker(2)
&gt;&gt;&gt; t1.start(); t2.start()
I am worker 1
I am worker 2

# using function could be more flexible
&gt;&gt;&gt; def Worker(worker_id):
...   print "I am worker %d" % worker_id
... 
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; t1 = Thread(target=Worker, args=(1,))
&gt;&gt;&gt; t2 = Thread(target=Worker, args=(2,))
&gt;&gt;&gt; t1.start()
I am worker 1
I am worker 2
</pre>
<h3>Thread Performance Problem - GIL</h3>
<pre class="code python">
# GIL - Global Interpreter Lock
# see: <a href="http://www.slideshare.net/emayssat/pythonunderstanding-gil">Ungerstanging the Python GIL</a>
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; def profile(func):
...   def wrapper(*args, **kwargs):
...     import time
...     start = time.time()
...     func(*args, **kwargs)
...     end   = time.time()
...     print end - start
...   return wrapper
...
&gt;&gt;&gt; @profile
... def nothread():
...   fib(35)
...   fib(35)
... 
&gt;&gt;&gt; @profile
... def hasthread():
...   t1=Thread(target=fib, args=(35,))
...   t2=Thread(target=fib, args=(35,))
...   t1.start(); t2.start()
...   t1.join(); t2.join()
... 
&gt;&gt;&gt; nothread()
9.51164007187
&gt;&gt;&gt; hasthread()
11.3131771088
# !Thread get bad Performance
</pre>
<h3>Thread Pool Templeate</h3>
<pre class="code python">
# producer and consumer architecture
from Queue import Queue
from threading import Thread

class Worker(Thread):
   def __init__(self,queue):
      super(Worker, self).__init__()
      self._q = queue
      self.daemon = True
      self.start()
   def run(self):
      while True:
         f,args,kwargs = self._q.get()
         try:
            print f(*args, **kwargs)
         except Exception as e:
            print e
         self._q.task_done()

class ThreadPool(object):
   def __init__(self, num_t=5):
      self._q = Queue(num_t)
      # Create Worker Thread
      for _ in range(num_t):
         Worker(self._q) 
   def add_task(self, f, *args, **kwargs):
      self._q.put((f, args, kwargs))
   def wait_complete(self):
      self._q.join()
      
def fib(n):
   if n &lt;= 2:
      return 1
   return fib(n-1)+fib(n-2) 

if __name__ == '__main__':
   pool = ThreadPool()
   for _ in range(3):
      pool.add_task(fib,35)
   pool.wait_complete()
</pre>


            </div>
            <div class="col-sm-4">
<h3>Synchronization Options in "threading"</h3>
<pre class="code python">
threading.Lock
threading.RLock
threading.Semaphore
threading.BoundedSemaphore
threading.Event
threading.Condition
</pre>

<h3>Mutex lock - using for synchronization primitive</h3>

<pre class="code python">
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; from threading import Lock
&gt;&gt;&gt; lock = Lock()
&gt;&gt;&gt; def getlock(id):
...   lock.acquire()
...   print "task{0} get".format(id)
...   lock.release()
... 
&gt;&gt;&gt; t1=Thread(target=getlock,args=(1,))
&gt;&gt;&gt; t2=Thread(target=getlock,args=(2,))
&gt;&gt;&gt; t1.start();t2.start()
task1 get
task2 get

# using lock manager
&gt;&gt;&gt; def getlock(id):
...   with lock:
...     print "task%d get" % id
... 
&gt;&gt;&gt; t1=Thread(target=getlock,args=(1,))
&gt;&gt;&gt; t2=Thread(target=getlock,args=(2,))
&gt;&gt;&gt; t1.start();t2.start()
task1 get
task2 get
</pre>

<h3>Deadlock - happen when more than one mutex lock</h3>
<pre class="code python">
# deadlock example as below
&gt;&gt;&gt; import threading
&gt;&gt;&gt; import time
&gt;&gt;&gt; lock1 = threading.Lock()
&gt;&gt;&gt; lock2 = threading.Lock()
&gt;&gt;&gt; def task1():
...   with lock1:
...     print "get lock1"
...     time.sleep(3)
...     with lock2:
...       print "No deadlock"
... 
&gt;&gt;&gt; def task2():
...   with lock2:
...     print "get lock2"
...     with lock1:
...       print "No deadlock"
... 
&gt;&gt;&gt; t1=threading.Thread(target=task1)
&gt;&gt;&gt; t2=threading.Thread(target=task2)
&gt;&gt;&gt; t1.start();t2.start()
get lock1
 get lock2

&gt;&gt;&gt; t1.isAlive()
True
&gt;&gt;&gt; t2.isAlive()
True
</pre>


<h3>RLock - Reentrant Lock</h3>
<pre class="code python">
# ref:<a href="http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency?related=1"> SlideShare - David Beazley</a>
# "monitor object" 
</pre>


<h3>Multiprocessing - Solving GIL Problem Via Processes</h3>
<pre class="code python">
# see: <a href="https://docs.python.org/2/library/multiprocessing.html">multiprocessing</a>
&gt;&gt;&gt; from multiprocessing import Pool
&gt;&gt;&gt; def fib(n):
...   if n &gt;= 2:
...     return 1
...   return fib(n-1)+fib(n-2)
... 
&gt;&gt;&gt; def profile(func):
...   def wrapper(*args, **kwargs):
...     import time
...     start = time.time()
...     func(*args, **kwargs)
...     end   = time.time()
...     print end - start
...   return wrapper
... 
&gt;&gt;&gt; @profile
... def nomultiprocess():
...   map(fib,[35]*5)
... 
&gt;&gt;&gt; @profile
... def hasmultiprocess():
...   pool = Pool(5)
...   pool.map(fib,[35]*5)
... 
&gt;&gt;&gt; nomultiprocess()
23.8454811573
&gt;&gt;&gt; hasmultiprocess()
13.2433719635
</pre>
            </div>
            <div class="col-sm-4">
<h3>Simple round-robin Scheduler</h3>
<pre class="code python">
&gt;&gt;&gt; def fib(n):
...   if n &lt;= 2:
...     return 1
...   return fib(n-1)+fib(n-2)
... 
&gt;&gt;&gt; def gen_fib(n):
...   for _ in range(1,n+1):
...     yield fib(_)
...
&gt;&gt;&gt; t=[gen_fib(5),gen_fib(3)]
&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; tasks = deque()
&gt;&gt;&gt; tasks.extend(t)
&gt;&gt;&gt; def run(tasks):
...   while tasks:
...     try:
...       task = tasks.popleft()
...       print task.next()
...       tasks.append(task)
...     except StopIteration:
...       print "done"
... 
&gt;&gt;&gt; run(tasks)
1
1
1
1
2
2
3
done
5
done
</pre>
<h3>Simple round-robin Scheduler with blocking function</h3>
<pre class="code python">
# ref: <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">PyCon 2015 - David Beazley</a>
import socket
from select import select
from collections import deque

tasks  = deque()
r_wait = {}
s_wait = {}

def fib(n):
   if n &lt;= 2:
      return 1
   return fib(n-1)+fib(n-2)

def run():
   while any([tasks,r_wait,s_wait]):
      while not tasks:
         # polling
         rr, sr, _ = select(r_wait, 
                        s_wait, {})
         for _ in rr:
            tasks.append(r_wait.pop(_))
         for _ in sr:
            tasks.append(s_wait.pop(_))
      try:
         task = tasks.popleft()
         why,what = task.next()
         if why == 'recv':
            r_wait[what] = task
         elif why == 'send':
            s_wait[what] = task
         else:
            raise RuntimeError
      except StopIteration:
         pass
def fib_server():
   sock = socket.socket(
         socket.AF_INET,
         socket.SOCK_STREAM)
   sock.setsockopt(
         socket.SOL_SOCKET,
         socket.SO_REUSEADDR,1)
   sock.bind(('localhost',5566))
   sock.listen(5)
   while True:
      yield 'recv', sock
      c, a = sock.accept()
      tasks.append(fib_handler(c))
      
def fib_handler(client):
   while True:
      yield 'recv', client
      req  = client.recv(1024)
      if not req:
         break
      resp = fib(int(req))
      yield 'send', client
      client.send(str(resp)+'\n')
   client.close()

tasks.append(fib_server())
run()
# bash1&gt; nc loalhost 5566
# 20
# 6765
# bash2&gt; nc localhost 5566 
# 10
# 55
</pre>


            </div>
         </div>
      </div>
   </body>

</html>
