<!DOCTYPE html>

<html>
   <head>
   
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
      <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
      <link rel="stylesheet" href="highlight/styles/github.css">
      <link rel="stylesheet" href="css/style.css">
      <script src="highlight/highlight.pack.js"></script>
      <script>
         $(document).ready(function(){
            $('pre.code').each(function(i, block) {
               hljs.highlightBlock(block);
            }); 
         });
      </script> 
   </head>

   <body>
      <div class="container">
         <div class="jumbotron" style="background-color:white">
            <h1>Python Cheat Sheet</h1>
            <p>Cheat sheet of Python. Some concurrency concept for Python programmer need to know.</p>
         </div>
         <div class="row">
            <div class="col-sm-4">
<h3>Create a Thread Via threading</h3>
<pre class="code python">
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; class Worker(Thread):
...   def __init__(self, id):
...     super(Worker, self).__init__()
...     self._id = id
...   def run(self):
...     print "I am worker %d" % self._id
... 
&gt;&gt;&gt; t1 = Worker(1)
&gt;&gt;&gt; t2 = Worker(2)
&gt;&gt;&gt; t1.start(); t2.start()
I am worker 1
I am worker 2

# using function could be more flexible
&gt;&gt;&gt; def Worker(worker_id):
...   print "I am worker %d" % worker_id
... 
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; t1 = Thread(target=Worker, args=(1,))
&gt;&gt;&gt; t2 = Thread(target=Worker, args=(2,))
&gt;&gt;&gt; t1.start()
I am worker 1
I am worker 2
</pre>
<h3>Thread Performance Problem - GIL</h3>
<pre class="code python">
# GIL - Global Interpreter Lock
# see: <a href="http://www.slideshare.net/emayssat/pythonunderstanding-gil">Ungerstanging the Python GIL</a>
&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; def profile(func):
...   def wrapper(*args, **kwargs):
...     import time
...     start = time.time()
...     func(*args, **kwargs)
...     end   = time.time()
...     print end - start
...   return wrapper
...
&gt;&gt;&gt; @profile
... def nothread():
...   fib(35)
...   fib(35)
... 
&gt;&gt;&gt; @profile
... def hasthread():
...   t1=Thread(target=fib, args=(35,))
...   t2=Thread(target=fib, args=(35,))
...   t1.start(); t2.start()
...   t1.join(); t2.join()
... 
&gt;&gt;&gt; nothread()
9.51164007187
&gt;&gt;&gt; hasthread()
11.3131771088
# !Thread get bad Performance
</pre>
<h3>Thread Pool Templeate</h3>
<pre class="code python">
# producer and consumer architecture
from Queue import Queue
from threading import Thread

class Worker(Thread):
   def __init__(self,queue):
      super(Worker, self).__init__()
      self._q = queue
      self.daemon = True
      self.start()
   def run(self):
      while True:
         f,args,kwargs = self._q.get()
         try:
            print f(*args, **kwargs)
         except Exception as e:
            print e
         self._q.task_done()

class ThreadPool(object):
   def __init__(self, num_t=5):
      self._q = Queue(num_t)
      # Create Worker Thread
      for _ in range(num_t):
         Worker(self._q) 
   def add_task(self, f, *args, **kwargs):
      self._q.put((f, args, kwargs))
   def wait_complete(self):
      self._q.join()
      
def fib(n):
   if n &lt;= 2:
      return 1
   return fib(n-1)+fib(n-2) 

if __name__ == '__main__':
   pool = ThreadPool()
   for _ in range(3):
      pool.add_task(fib,35)
   pool.wait_complete()
</pre>


            </div>
            <div class="col-sm-4">
<h3>Multiprocessing - Solving GIL Problem Via Processes</h3>
<pre class="code python">
# see: <a href="https://docs.python.org/2/library/multiprocessing.html">multiprocessing</a>
&gt;&gt;&gt; from multiprocessing import Pool
&gt;&gt;&gt; def fib(n):
...   if n &gt;= 2:
...     return 1
...   return fib(n-1)+fib(n-2)
... 
&gt;&gt;&gt; def profile(func):
...   def wrapper(*args, **kwargs):
...     import time
...     start = time.time()
...     func(*args, **kwargs)
...     end   = time.time()
...     print end - start
...   return wrapper
... 
&gt;&gt;&gt; @profile
... def nomultiprocess():
...   map(fib,[35]*5)
... 
&gt;&gt;&gt; @profile
... def hasmultiprocess():
...   pool = Pool(5)
...   pool.map(fib,[35]*5)
... 
&gt;&gt;&gt; nomultiprocess()
23.8454811573
&gt;&gt;&gt; hasmultiprocess()
13.2433719635
</pre>
            </div>
            <div class="col-sm-4">
               <h3>Test</h3>
            </div>
         </div>
      </div>
   </body>

</html>
