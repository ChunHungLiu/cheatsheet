<!DOCTYPE html>

<html>
   <head>
   
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
      <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
      <link rel="stylesheet" href="highlight/styles/github.css">
      <link rel="stylesheet" href="css/style.css">
      <script src="highlight/highlight.pack.js"></script>
      <script>
         $(document).ready(function(){
            $('pre.code').each(function(i, block) {
               hljs.highlightBlock(block);
            }); 
         });
      </script> 
   </head>

   <body>
      <div class="container" style="width:9<D-r>0%">
         <div class="jumbotron" style="background:white;">
            <h1>Python Cheat Sheet</h1>
            <p>Cheat sheet of Python. Some basic concepts for Python programmer need to know.</p>
         </div>
         <div class="row">
            <div class="col-sm-4">
<h3>Python Naming Styles</h3>
<pre class="code python">
# see: PEP8
# for public use
var

# for internal use
_var

# convention to avoid conflict keyword 
var_

# for private use in class
__var

# for protect use in class
_var_

# "magic" method or attributes
# ex: __init__, __file__, __main__
__var__

# "throwaway" variable name
# usually used in loop
# ex: [_ for _ in range(10)]
_
</pre>
<h3>Common Use "Magic"</h3>
<pre class="code python">
# For command class

__main__
__name__
__file__
__module__
__doc__
__init____init__(self, [...)
__str__(self)
__repr__(self)
__del__(self)

# For Descriptor
__get__(self, instance, owner)
__set__(self, instance, value)
__delete__(self, instance)

# For Context Manager
__enter__(self)
__exit__(self, exc_ty, exc_val, tb)

# Emulating container types
__len__(self)
__getitem__(self, key)
__setitem__(self, key, value)
__delitem__(self, key)
__iter__(self)

# Controlling Attribute Access
__getattr__(self, name)
__setattr__(self, name, value)
__delattr__(self, name)
__getattribute__(self, name)

# Callable object
__call__(self, [args...])

# Compare related
__cmp__(self, other)
__eq__(self, other)
__ne__(self, other)
__lt__(self, other)
__gt__(self, other)
__le__(self, other)
__ge__(self, other)

# arithmetical operation related
__add__(self, other)
__sub__(self, other)
__mul__(self, other)
__div__(self, other)
__mod__(self, other)
__and__(self, other)
__or__(self, other)
__xor__(self, other)
</pre>
            </div>
            <div class="col-sm-4">
<h3>Check object attributes</h3>
<pre class="code python">
# example of check list attributes
&gt;&gt;&gt; dir(list)
['__add__', '__class__', ...]
<D-r></pre>

<h3>Define a function __doc__</h3>
<pre class="code python">
# Define a function document
&gt;&gt;&gt; def Example():
...   """ This is an example function """
...   print "Example function"
...
&gt;&gt;&gt; Example.__doc__
' This is an example function '

# Or using help function
&gt;&gt;&gt; help(Example)
</pre>

<h3>Representations of your class behave</h3>

<pre class="code python">
&gt;&gt;&gt; class example(object):
...    def __str__(self):
...       return "example __str__"
...    def __repr__(self):
...       return "example __repr__"
... 
&gt;&gt;&gt; print str(example())
example __str__
&gt;&gt;&gt; example()
example __repr__
</pre>

<h3>Get list item "SMART"</h3>
<pre class="code python">
&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; a[0]
1
&gt;&gt;&gt;a[-1]
5
&gt;&gt;&gt; a[0:]
[1,2,3,4,5]
&gt;&gt;&gt; a[:-1]
[1,2,3,4]

# a[start:end:step]
&gt;&gt;&gt; a[0:-1:2]
[1,3]

# using slice object
# slice(start,end,step)
&gt;&gt;&gt; s = slice(0,-1,2)
&gt;&gt;&gt; a[s]
[1,3]
</pre>
<h3>Delegating Iteration (__iter__)</h3>
<pre class="code python">
# __iter__ return an iterator object
# Be careful: list is an "iterable" object not an "iterator" 
&gt;&gt;&gt; class example(object):
...    def __init__(self,list_):
...       self._list = list_
...    def __iter__(self):
...    return iter(self,self._list)
...
&gt;&gt;&gt; ex = example([1,2,3,4,5])
&gt;&gt;&gt; for _ in ex: print _,
...
1 2 3 4 5
</pre>

<h3>Using Generator as Iterator</h3>
<pre class="code python">
# see: PEP289
&gt;&gt;&gt; a = (_ for _ in range(10))
&gt;&gt;&gt; for _ in a: print _,
&gt;&gt;&gt; for _ in a: print _,
... 
0 1 2 3 4 5 6 7 8 9

# equivalent to
&gt;&gt;&gt; def _gen():
...   for _ in range(10):
...     yield _
... 
&gt;&gt;&gt; a = _gen()
&gt;&gt;&gt; for _ in a: print _,
... 
0 1 2 3 4 5 6 7 8 9 
</pre>

<h3>Decorator</h3>
<pre class="code python">
# see: PEP318
&gt;&gt;&gt; def decor(func):
...   def wrapper(*args,**kwargs):
...     print "wrapper"
...     func()
...     print "-------"
...   return wrapper
... 
&gt;&gt;&gt; @decor
... def example():
...   print "Example"
... 
&gt;&gt;&gt; example()
wrapper
Example
-------

# equivalent to
&gt;&gt;&gt; def example():
...   print "Example"
... 
&gt;&gt;&gt; example = decor(example)
&gt;&gt;&gt; example()
wrapper
Example
-------
</pre>

            </div>
            <div class="col-sm-4">
<h3>"with" statement (Context Manager)</h3>
<pre class="code python">
# replace try: ... finally: ...
# see: PEP343
# common use in open and close
# example:
import socket
class Socket(object):
   def __enter__(self):
      self.sock = socket.socket(
                     socket.AF_INET,
                     socket.SOCK_STREAM   
                  )
      return self.sock

   def __exit__(self,exc_ty,exc_val,tb):
      if exc_ty is not None:
         print exc_ty
      self.sock.close()

if __name__=="__main__":
   host = 'localhost'
   port 5566
   with Socket() as s:
      s.bind((host,port))
      s.listen(5)
      while True:
         s.accept()
         msg = s.recv(1024)
         print msg
         s.send(msg)
</pre>
<h3>Using "contextlib" implement Context Manager</h3>
<pre class="code python">
from contextlib import contextmanager
@contextmanager
   def opening(filename):
      f = open(filename)
      try:
          yield f
      finally:
          f.close()
          
with opening('example.txt','r') as fd:
   fd.read()
</pre>

<h3>Using "with" statement open file</h3>
<pre class="code python">
&gt;&gt;&gt; with open("example",'r') as f:
...    content = f.read()
</pre>

<h3>Property - Managed attributes</h3>
<pre class="code python">
class example(object):
   def __init__(self,value):
      self.val = value
   
   @property
   def val(self):
      return self._val

   @val.setter
   def val(self,value):
      if not isintance(value,int):
         raise TypeError("Expect int")
      self._val = value

   @ val.deleter
   def val(self):
      del self._val

# example result:
&gt;&gt;&gt; ex = example(123)
&gt;&gt;&gt; ex.val = "str"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "test.py", line 12, in val
    raise TypeError("Expect int")
TypeError: Expect int
</pre>

<h3>Computed attribures - Using property</h3>
<pre class="code python">
# Concept: Attribure's value is not store in memory. Computing the value only when we need.
&gt;&gt;&gt; class example(object):
...   @property
...   def square3(self):
...     return 2**3
... 
&gt;&gt;&gt; ex = example()
&gt;&gt;&gt; ex.square3
8
</pre>


            </div>
         </div>
      </div>
   </body>

</html>
